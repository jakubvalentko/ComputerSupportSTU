---
title: "task 2"
format: html
editor: visual
---
```{r}
### Task 1: Exploring Data Types in R

# 1.1 Atomic Types
temperature <- 23.5
gravity <- 9.8
radius <- 6371.0
population_millions <- 8.2

moons <- 2L
cities <- 12L
inhabitants <- 8200000L

has_water <- TRUE
is_inhabited <- TRUE

planet_name <- "Kubova planeta"
region <- "Stropkov"
category <- "nechutna"

cat("Planet", planet_name, "in the", region, 
    "is a", category, "with", moons, "moons and population of", population_millions, "million.\n")

# 1.2 Vectors
num_vec <- c(temperature, gravity, radius, population_millions, moons, cities, inhabitants)
seq_vec <- seq(20, 100, by = 5)
set.seed(123)
log_vec <- sample(c(TRUE, FALSE), 10, replace = TRUE)

# 1.3 Matrix
set.seed(42)
planet_matrix <- matrix(sample(-50:50, 9), nrow = 3)
rownames(planet_matrix) <- c("Aurelia", "Borealis", "Cygna")
colnames(planet_matrix) <- c("Energy", "Resources", "Habitability")
rowMeans(planet_matrix)
colMeans(planet_matrix)

# 1.4 List
universe <- list(
  description = "A fictional planetary system with diverse worlds.",
  numeric_values = num_vec,
  sequence_vector = seq_vec,
  logical_vector = log_vec,
  matrix3x3 = planet_matrix
)

# 1.5 Factor
planet_class <- factor(c("low", "medium", "high", "medium", "low", "high"))
table(planet_class)

# 1.6 Data Frame
your_df <- data.frame(
  planet = c("Aurelia", "Borealis", "Cygna", "Draconis", "Elysium"),
  population = c(8200000, 0, 1200, 50000, 300000),
  is_habitable = c(TRUE, FALSE, TRUE, FALSE, TRUE),
  region = c("Inner", "Outer", "Inner", "Outer", "Inner")
)
colnames(your_df) <- c("Planet", "Population", "Habitable", "Region")
str(your_df)
summary(your_df)
your_df$PopDensity <- your_df$Population / 1000

### Task 2: Subsetting & Missing Data

# 2.1 Querying Vectors
seq_vec[3]
seq_vec[2:5]
seq_vec[seq_vec > 50]

log_vec[log_vec]
which(log_vec)

# 2.2 Querying Universe List
universe$description
universe[[4]]       # matrix
universe[[2]][2]    # second element from numeric vector

# 2.3 Investigating Data Frame
head(your_df, 3)
your_df[4, 1]
your_df$Habitable

df_subset <- your_df[your_df$Population > 1000, ]
df_subset_2 <- your_df[your_df$Region %in% c("Inner", "Outer"), ]

# 2.4 Handling Corrupted Data (NA)
df_corrupted <- your_df
df_corrupted[2, 2] <- NA
df_corrupted[3, 3] <- NA
df_corrupted[5, 1] <- NA

sum(is.na(df_corrupted))
colSums(is.na(df_corrupted))
mean(df_corrupted$Population, na.rm = TRUE)
df_clean <- na.omit(df_corrupted)

# 2.5 Bonus Challenge: which()
highest_pop_index <- which.max(your_df$Population)
your_df[highest_pop_index, ]

lowest_pop_index <- which.min(your_df$Population)
your_df[lowest_pop_index, ]
```
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
